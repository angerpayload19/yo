//go:build !regexp

// Copyright (C) 2020 - 2022 iDigitalFlame
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

package text

import (
	"strconv"

	"github.com/iDigitalFlame/xmt/util"
)

type tokenMatcher struct {
	_ [0]func()
	v string
	i bool
}

func isChar(v byte) bool {
	switch {
	case v >= 'a' && v <= 'z':
		fallthrough
	case v >= 'A' && v <= 'Z':
		fallthrough
	case v >= '0' && v <= '9':
		return true
	default:
		return false
	}
}
func isUpper(v byte) bool {
	return v >= 'A' && v <= 'Z'
}
func isLower(v byte) bool {
	return v >= 'a' && v <= 'z'
}
func isLetter(v byte) bool {
	return (v >= 'a' && v <= 'z') || (v >= 'A' && v <= 'Z')
}
func isNumber(v byte) bool {
	return v >= '0' && v <= '9'
}
func numSize(v, b int) int {
	var (
		n = v
		c int
	)
	for n > 0 {
		c++
		n = n / b
	}
	return c
}
func isNumberHex(v byte) bool {
	return (v >= '0' && v <= '9') || (v >= 'a' && v <= 'f') || (v >= 'A' && v <= 'F')
}

// String parses this MatchString value and will preform any replacements and
// fill any variables contained.
func (s Matcher) String() string {
	var (
		l = -2
		b = builders.Get().(*util.Builder)
		f bool
		n uint64
	)
	b.Grow(len(s))
	for i := range s {
		switch {
		case s[i] == '%':
			if l > -1 {
				if s[l] == '%' {
					b.WriteString((string)(s[l : i+1]))
					l = -1
					continue
				}
				b.WriteString((string)(s[l:i]))
			}
			l = i
		case l > -1 && i > 0 && i-l == 1 && (s[i] == 'n' || s[i] == 'c' || s[i] == 'u' || s[i] == 'l'):
			b.WriteString((string)(s[l : i+1]))
			l = -1
		case l > -1 && i > 0 && (s[i] == 'n' || s[i] == 'c' || s[i] == 'u' || s[i] == 'l' || s[i] == 's' || s[i] == 'd' || s[i] == 'h'):
			if i-l > 1 {
				if f = s[i-1] == 'f'; f {
					n, _ = strconv.ParseUint((string)(s[l+1:i-1]), 10, 64)
				} else {
					n, _ = strconv.ParseUint((string)(s[l+1:i]), 10, 64)
				}
			} else {
				f, n = false, 0
			}
			writeToken(b, s[i], f, int(n))
			l = -1
		case s[i] == 'f':
			if l > -1 && i-l == 1 {
				b.WriteString((string)(s[l : i+1]))
				l = -1
				continue
			}
			fallthrough
		case s[i] >= '0' && s[i] <= '9':
			if l > -1 {
				continue
			}
			b.WriteByte(s[i])
		default:
			if l > -1 {
				b.WriteString((string)(s[l : i+1]))
				l = -1
				continue
			}
			b.WriteByte(s[i])
		}
	}
	if l == -2 {
		return string(s)
	}
	if l == -1 {
		v := b.Output()
		builders.Put(b)
		return v
	}
	if l < len(s) {
		b.WriteString((string)(s[l:]))
	}
	v := b.Output()
	builders.Put(b)
	return v
}

// MatchEx returns a valid Regexp struct that is guaranteed to match any string
func matchWithToken(s, v string) bool {
	if len(s) == 0 || len(v) == 0 {
		return false
	}
	var (
		l, w, z = -2, 0, 0
		f       bool
		n       uint64
	)
	for i := range s {
		switch {
		case s[i] == '%':
			if l > -1 {
				if s[l] == '%' {
					if s[i] != v[w] {
						return false
					}
					l, w = -1, w+2
					continue
				}
			}
			l = i
		case l > -1 && i > 0 && i-l == 1 && (s[i] == 'n' || s[i] == 'c' || s[i] == 'u' || s[i] == 'l'):
			l = -1
		case l > -1 && i > 0 && (s[i] == 'n' || s[i] == 'c' || s[i] == 'u' || s[i] == 'l' || s[i] == 's' || s[i] == 'd' || s[i] == 'h'):
			if i-l > 1 {
				if f = s[i-1] == 'f'; f {
					n, _ = strconv.ParseUint(s[l+1:i-1], 10, 64)
				} else {
					n, _ = strconv.ParseUint(s[l+1:i], 10, 64)
				}
			} else {
				f, n = false, 0
			}
			if z, f = checkToken(s[i], f, int(n), v[w:]); !f {
				return false
			}
			l, w = -1, w+z
		case s[i] == 'f':
			if l > -1 && i-l == 1 {
				if s[i] != v[w] {
					return false
				}
				l, w = -1, w+1
				continue
			}
			fallthrough
		case s[i] >= '0' && s[i] <= '9':
			if l > -1 {
				continue
			}
			if s[i] != v[w] {
				return false
			}
			w++
		default:
			if l > -1 {
				for y := l; y <= i; y++ {
					if s[y] != v[w+(y-l)] {
						return false
					}
				}
				w += (i - l) + 1
				l = -1
				continue
			}
			if len(v) < w {
				return false
			}
			if s[i] != v[w] {
				return false
			}
			w++
		}
	}
	if l < 0 {
		return l == -1 || (l == -2 && s == v)
	}
	if l < len(s) {
		return len(s)-l == len(v)-w && s[l:] == v[w:]
	}
	return false
}
func (t tokenMatcher) String() string {
	return t.v
}

// MatchEx returns a valid Regexp struct that is guaranteed to match any string
// generated by the Matcher's 'String' function. MatchEx returns an inverse
// matcher if the bool is false.
func (s Matcher) MatchEx(o bool) Regexp {
	if len(s) == 0 {
		return MatchAny
	}
	if s == "*" {
		return MatchAny
	}
	return tokenMatcher{v: string(s), i: !o}
}
func (t tokenMatcher) Match(b []byte) bool {
	return t.MatchString(string(b))
}
func (t tokenMatcher) MatchString(s string) bool {
	if t.i {
		return !matchWithToken(t.v, s)
	}
	return matchWithToken(t.v, s)
}
func writeToken(b *util.Builder, c byte, f bool, n int) {
	switch {
	case c == 's' && !f && n == 0:
		b.WriteString(Rand.StringRange(1, 1+int(util.FastRandN(256))))
	case c == 's' && !f && n > 0:
		b.WriteString(Rand.StringRange(1, n))
	case c == 's' && f && n > 0:
		b.WriteString(Rand.String(n))
	case c == 'd' && !f && n == 0:
		b.WriteString(strconv.FormatUint(uint64(util.FastRand()), 10))
	case c == 'd' && !f && n > 0:
		b.WriteString(strconv.FormatUint(uint64(util.FastRandN(n)), 10))
	case c == 'd' && f:
		b.WriteString(strconv.FormatUint(uint64(n), 10))
	case c == 'h' && !f && n == 0:
		b.WriteString(strconv.FormatUint(uint64(util.FastRand()), 16))
	case c == 'h' && !f && n > 0:
		b.WriteString(strconv.FormatUint(uint64(util.FastRandN(n)), 16))
	case c == 'h' && f:
		b.WriteString(strconv.FormatUint(uint64(n), 16))
	case c == 'n' && !f:
		b.WriteString(Rand.StringNumberRange(1, n))
	case c == 'n' && f:
		b.WriteString(Rand.StringNumber(n))
	case c == 'c' && !f:
		b.WriteString(Rand.StringCharactersRange(1, n))
	case c == 'c' && f:
		b.WriteString(Rand.StringCharacters(n))
	case c == 'u' && !f:
		b.WriteString(Rand.StringUpperRange(1, n))
	case c == 'u' && f:
		b.WriteString(Rand.StringUpper(n))
	case c == 'l' && !f:
		b.WriteString(Rand.StringLowerRange(1, n))
	case c == 'l' && f:
		b.WriteString(Rand.StringLower(n))
	}
}
func checkToken(c byte, f bool, n int, v string) (int, bool) {
	if len(v) == 0 {
		return 0, false
	}
	var x func(byte) bool
	switch {
	case c == 's':
		x = isChar
	case c == 'd' || c == 'n':
		x = isNumber
	case c == 'h':
		x = isNumberHex
	case c == 'c':
		x = isLetter
	case c == 'u':
		x = isUpper
	case c == 'l':
		x = isLower
	default:
		return 0, false
	}
	if !f {
		if !x(v[0]) {
			return 0, false
		}
		if n == 0 {
			n = 256
		}
		for i := 1; i < len(v) && i < n; i++ {
			if !x(v[i]) {
				return i, true
			}
		}
		return n, true
	}
	switch c {
	case 'h':
		n = numSize(n, 16)
	case 'd': //, 'n':
		n = numSize(n, 10)
	}
	if len(v) < n {
		return 0, false
	}
	for i := 0; i < n; i++ {
		if !x(v[i]) {
			return 0, false
		}
	}
	return n, true
}
