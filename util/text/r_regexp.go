//go:build regexp
// +build regexp

// Copyright (C) 2020 - 2023 iDigitalFlame
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

package text

import (
	"regexp"
	"strconv"
	"strings"

	"github.com/iDigitalFlame/xmt/util"
)

type inverseRegexp string

// String parses this MatchString value and will preform any replacements and
// fill any variables contained.
func (s Matcher) String() string {
	if len(s) == 0 {
		return string(s)
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if len(m) == 0 {
		return string(s)
	}
	var (
		l   int
		err error
		b   = builders.Get().(*util.Builder)
	)
	b.Grow(len(s))
	for x, v, c := 0, 0, ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				v, err = strconv.Atoi(string(s[m[x][4] : m[x][5]-1]))
			} else {
				v, err = strconv.Atoi(string(s[m[x][4]:m[x][5]]))
			}
			if err != nil {
				v = -1
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringNumber(v)
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringCharacters(v)
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringUpper(v)
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringLower(v)
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.String(v)
		case s[m[x][1]-1] == 'd' && s[m[x][1]-2] == 'f' && v >= 0:
			c = util.Uitoa(uint64(v))
		case s[m[x][1]-1] == 'h' && s[m[x][1]-2] == 'f' && v >= 0:
			c = util.Uitoa16(uint64(v))
		case s[m[x][1]-1] == 'd' && v >= 0:
			c = util.Uitoa(uint64(util.FastRandN(v)))
		case s[m[x][1]-1] == 'h' && v >= 0:
			c = util.Uitoa16(uint64(util.FastRandN(v)))
		case s[m[x][1]-1] == 'n' && v > 0:
			c = Rand.StringNumberRange(1, v)
		case s[m[x][1]-1] == 'c' && v > 0:
			c = Rand.StringCharactersRange(1, v)
		case s[m[x][1]-1] == 'u' && v > 0:
			c = Rand.StringUpperRange(1, v)
		case s[m[x][1]-1] == 'l' && v > 0:
			c = Rand.StringLowerRange(1, v)
		case s[m[x][1]-1] == 's' && v > 0:
			c = Rand.StringRange(1, v)
		case s[m[x][1]-1] == 's':
			c = Rand.StringRange(1, 1+int(util.FastRandN(256)))
		case s[m[x][1]-1] == 'd':
			c = util.Uitoa(uint64(util.FastRand()))
		case s[m[x][1]-1] == 'h':
			c = util.Uitoa16(uint64(util.FastRand()))
		default:
			c = string(s[m[x][0]:m[x][1]])
		}
		b.WriteString(string(s[l:m[x][0]]))
		b.WriteString(c)
		c, l = "", m[x][1]
	}
	if l < len(s) {
		b.WriteString(string(s[l:]))
	}
	o := b.String()
	b.Reset()
	builders.Put(b)
	return o
}
func (i inverseRegexp) String() string {
	return string(i)
}

// MatchEx returns a valid Regexp struct that is guaranteed to match any string
// generated by the Matcher's 'String' function. MatchEx returns an inverse
// matcher if the bool is false.
func (s Matcher) MatchEx(o bool) Regexp {
	if len(s) == 0 {
		return MatchAny
	}
	if s == "*" {
		return MatchAny
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if len(m) == 0 {
		if !o {
			return inverseRegexp(s)
		}
		if r, err := regexp.Compile(`^(` + regexp.QuoteMeta(string(s)) + `)$`); err == nil {
			return r
		}
		return MatchNone
	}
	var (
		l   int
		d   string
		err error
		b   = builders.Get().(*util.Builder)
	)
	if b.WriteString("^("); !o {
		d = "^"
	}
	for x, v, c, q := 0, 0, "", ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				v, err = strconv.Atoi(string(s[m[x][4] : m[x][5]-1]))
			} else {
				v, err = strconv.Atoi(string(s[m[x][4]:m[x][5]]))
			}
			if err != nil {
				v, q = -1, "0"
			} else {
				q = util.Uitoa(uint64(v))
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'd':
			c = `([` + d + `0-9]+)`
		case s[m[x][1]-1] == 'h':
			c = `([` + d + `a-fA-F0-9]+)`
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `0-9]{` + q + `})`
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-zA-Z]{` + q + `})`
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `A-Z]{` + q + `})`
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-z]{` + q + `})`
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-zA-Z0-9]{` + q + `})`
		case s[m[x][1]-1] == 'n' && v > 0:
			c = `([` + d + `0-9]{1,` + q + `})`
		case s[m[x][1]-1] == 'c' && v > 0:
			c = `([` + d + `a-zA-Z]{1,` + q + `})`
		case s[m[x][1]-1] == 'u' && v > 0:
			c = `([` + d + `A-Z]{1,` + q + `})`
		case s[m[x][1]-1] == 'l' && v > 0:
			c = `([` + d + `a-z]{1,` + q + `})`
		case s[m[x][1]-1] == 's' && v > 0:
			c = `([` + d + `a-zA-Z0-9]{1,` + q + `})`
		case s[m[x][1]-1] == 's':
			c = `([` + d + `a-zA-Z0-9]+)`
		default:
			c = string(s[m[x][0]:m[x][1]])
		}
		b.WriteString(strings.Replace(regexp.QuoteMeta(string(s[l:m[x][0]])), "/", "\\/", -1))
		b.WriteString(c)
		l = m[x][1]
	}
	if l < len(s) {
		b.WriteString(strings.Replace(regexp.QuoteMeta(string(s[l:])), "/", "\\/", -1))
	}
	b.WriteString(")$")
	r, err := regexp.Compile(b.Output())
	if builders.Put(b); err != nil {
		return MatchAny
	}
	return r
}
func (i inverseRegexp) Match(b []byte) bool {
	return string(i) != string(b)
}
func (i inverseRegexp) MatchString(s string) bool {
	return string(i) != s
}
